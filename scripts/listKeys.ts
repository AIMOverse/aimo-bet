/**
 * List Solana Keypairs from .keys/ directory
 *
 * Usage:
 *   npx tsx scripts/listKeys.ts [options]
 *
 * Options:
 *   --env      Output environment variables for .env file
 *   --json     Output as JSON
 *   (default)  Human-readable table format
 *
 * Examples:
 *   npx tsx scripts/listKeys.ts           # List all keys
 *   npx tsx scripts/listKeys.ts --env     # Output .env format
 *   npx tsx scripts/listKeys.ts --json    # Output JSON format
 */

import { readdir, readFile } from "node:fs/promises";
import { join } from "node:path";
import { getBase58Decoder } from "@solana/kit";

const KEYS_DIR = ".keys";

// Model names for env var generation (matches catalog.ts order)
const MODEL_ENV_NAMES = [
  "GPT",
  "CLAUDE",
  "GEMINI",
  "GROK",
  "DEEPSEEK",
  "GLM",
  "QWEN",
  "KIMI",
];

interface KeyInfo {
  filename: string;
  publicKey: string;
  privateKey: string;
}

async function loadKeypair(filename: string): Promise<KeyInfo> {
  const filepath = join(KEYS_DIR, filename);
  const content = await readFile(filepath, "utf-8");
  const secretKeyArray: number[] = JSON.parse(content);

  // Secret key is 64 bytes: first 32 = private key, last 32 = public key
  const secretKeyBytes = new Uint8Array(secretKeyArray);
  const privateKeyBytes = secretKeyBytes.slice(0, 32);
  const publicKeyBytes = secretKeyBytes.slice(32);

  // Decode to base58
  const decoder = getBase58Decoder();
  const publicKey = decoder.decode(publicKeyBytes);
  const privateKey = decoder.decode(secretKeyBytes); // Full 64-byte secret key

  return {
    filename,
    publicKey,
    privateKey,
  };
}

async function listAllKeys(): Promise<KeyInfo[]> {
  try {
    const files = await readdir(KEYS_DIR);
    const jsonFiles = files.filter((f) => f.endsWith(".json")).sort();

    const keys: KeyInfo[] = [];
    for (const file of jsonFiles) {
      const keyInfo = await loadKeypair(file);
      keys.push(keyInfo);
    }

    return keys;
  } catch (err) {
    if ((err as NodeJS.ErrnoException).code === "ENOENT") {
      console.error(`Error: ${KEYS_DIR}/ directory not found.`);
      console.error(`Run 'npx tsx scripts/generateKeys.ts' first.`);
      process.exit(1);
    }
    throw err;
  }
}

function printTable(keys: KeyInfo[]): void {
  if (keys.length === 0) {
    console.log("No keypairs found in .keys/ directory.");
    console.log("Run 'npx tsx scripts/generateKeys.ts' to generate keypairs.");
    return;
  }

  console.log("Solana Keypairs in .keys/\n");
  console.log("=".repeat(120));

  for (const key of keys) {
    console.log(`\nüìÅ ${key.filename}`);
    console.log(`   Public Key:  ${key.publicKey}`);
    console.log(`   Private Key: ${key.privateKey}`);
  }

  console.log("\n" + "=".repeat(120));
  console.log(`\nTotal: ${keys.length} keypair(s)`);
}

function printEnvVars(keys: KeyInfo[]): void {
  if (keys.length === 0) {
    console.error("No keypairs found.");
    process.exit(1);
  }

  console.log("# Solana (SVM) Wallet Keys for AI Agents");
  console.log("# Generated by scripts/listKeys.ts");
  console.log("# Copy these to your .env file\n");

  for (let i = 0; i < keys.length; i++) {
    const key = keys[i];
    const envName = MODEL_ENV_NAMES[i] || `WALLET_${i + 1}`;

    console.log(`# ${key.filename}`);
    console.log(`WALLET_${envName}_SVM_PUBLIC=${key.publicKey}`);
    console.log(`WALLET_${envName}_SVM_PRIVATE=${key.privateKey}`);
    console.log();
  }
}

function printJson(keys: KeyInfo[]): void {
  const output = keys.map((k, i) => ({
    index: i + 1,
    filename: k.filename,
    envPrefix: MODEL_ENV_NAMES[i] || `WALLET_${i + 1}`,
    publicKey: k.publicKey,
    svmPrivateKey: k.privateKey,
  }));

  console.log(JSON.stringify(output, null, 2));
}

async function main(): Promise<void> {
  const args = process.argv.slice(2);
  const outputEnv = args.includes("--env");
  const outputJson = args.includes("--json");

  const keys = await listAllKeys();

  if (outputEnv) {
    printEnvVars(keys);
  } else if (outputJson) {
    printJson(keys);
  } else {
    printTable(keys);
  }
}

main().catch((err) => {
  console.error("Error:", err);
  process.exit(1);
});
